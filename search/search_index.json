{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview This package mines and scrapes faculty profile information from a set of connected web pages at the University of Colorado with the goal of enabling data science on this valuable set of resources. The Colorado PROFILES search engine for biomedical research expertise and networking provides tools to help investigators and students find experts, potential collaborators or mentors, and to view past and present research networking of our investigators. The system consists of a set of web pages that catalog information about researchers, their publications, research topics, and the relationships between them. What is the goal of this project? The Colorado PROFILES website does not include any bulk download capability or a programmatically accessible application programming interface (API). The goal of this project is to generate bulk datasets ready for social network analysis, reporting, dashboard generation, and for further enrichment and integration with other resources. What does this project produce? This project employs web scraping to produce tables of: all researchers in the Colorado PROFILES system along with their affiliations and titles. all publications registered for each researcher relations between researchers and research area (given by MeSH terms ) quantified by a score (higher score indicates closer association between author and research area) derived relationships between authors as measured by MeSH term similarities See details below. Installation The package requires python 3.9 or greater. python -m pip install git@https://github.com/seandavi/cu_profile_utils Usage python -m cu_profile_utils.pipeline A network connection and ~4GB of RAM are needed. The build process will proceed to scrape all records, requiring >20,000 web requests (current as of November, 2022). A set of csv files representing the output will be created in the current working directory. Note The build process for the output files currently takes approximately 1 hour due to network bandwidth and server limitations. Output files profile_table.csv Column name Type Description name string The researcher name institution string The University of Colorado Campus to which the researcher belongs. department string The researcher's primary department title string The title or rank of the researcher profile_id integer The Colorado PROFILES researcher id number profile_pmids.csv Column name Type Description profile_id integer The Colorado PROFILES researcher id number pmid integer The Pubmed ID of the paper written by the researcher represented by the profile_id profile_mesh_sims.csv Column name Type Description profile_id integer The Colorado PROFILES researcher id number mesh_term string The preferred MeSH term as a string publication_count integer The total number of publications by the researcher with this profile_id most_recent_publication_year integer The latest year that this author published a paper with this MeSH term publication_count_all_authors integer The total number of papers in the Colorado PROFILES system with this MeSH term concept_score float A (unitless) score representing the extent to which this author is associated with this MeSH term (or concept) Reporting problems Problems or feature requests can be filed on Github . Develop If you want to develop additional functionality or make changes, the usual pull-request approach is the way to go. Local testing There is a minimal test suite available that uses tox and pytest . To run tests, do a checkout and install dependencies with poetry and then run: tox Documentation The fantastic MkDocs project is the framework for the documentation written in Markdown. With MkDocs installed, running mkdocs build will build the documentation in the site directory. mkdocs serve will serve up a live preview. Contribution Contributions are welcome....","title":"Overview"},{"location":"#overview","text":"This package mines and scrapes faculty profile information from a set of connected web pages at the University of Colorado with the goal of enabling data science on this valuable set of resources. The Colorado PROFILES search engine for biomedical research expertise and networking provides tools to help investigators and students find experts, potential collaborators or mentors, and to view past and present research networking of our investigators. The system consists of a set of web pages that catalog information about researchers, their publications, research topics, and the relationships between them.","title":"Overview"},{"location":"#what-is-the-goal-of-this-project","text":"The Colorado PROFILES website does not include any bulk download capability or a programmatically accessible application programming interface (API). The goal of this project is to generate bulk datasets ready for social network analysis, reporting, dashboard generation, and for further enrichment and integration with other resources.","title":"What is the goal of this project?"},{"location":"#what-does-this-project-produce","text":"This project employs web scraping to produce tables of: all researchers in the Colorado PROFILES system along with their affiliations and titles. all publications registered for each researcher relations between researchers and research area (given by MeSH terms ) quantified by a score (higher score indicates closer association between author and research area) derived relationships between authors as measured by MeSH term similarities See details below.","title":"What does this project produce?"},{"location":"#installation","text":"The package requires python 3.9 or greater. python -m pip install git@https://github.com/seandavi/cu_profile_utils","title":"Installation"},{"location":"#usage","text":"python -m cu_profile_utils.pipeline A network connection and ~4GB of RAM are needed. The build process will proceed to scrape all records, requiring >20,000 web requests (current as of November, 2022). A set of csv files representing the output will be created in the current working directory. Note The build process for the output files currently takes approximately 1 hour due to network bandwidth and server limitations.","title":"Usage"},{"location":"#output-files","text":"","title":"Output files"},{"location":"#profile_tablecsv","text":"Column name Type Description name string The researcher name institution string The University of Colorado Campus to which the researcher belongs. department string The researcher's primary department title string The title or rank of the researcher profile_id integer The Colorado PROFILES researcher id number","title":"profile_table.csv"},{"location":"#profile_pmidscsv","text":"Column name Type Description profile_id integer The Colorado PROFILES researcher id number pmid integer The Pubmed ID of the paper written by the researcher represented by the profile_id","title":"profile_pmids.csv"},{"location":"#profile_mesh_simscsv","text":"Column name Type Description profile_id integer The Colorado PROFILES researcher id number mesh_term string The preferred MeSH term as a string publication_count integer The total number of publications by the researcher with this profile_id most_recent_publication_year integer The latest year that this author published a paper with this MeSH term publication_count_all_authors integer The total number of papers in the Colorado PROFILES system with this MeSH term concept_score float A (unitless) score representing the extent to which this author is associated with this MeSH term (or concept)","title":"profile_mesh_sims.csv"},{"location":"#reporting-problems","text":"Problems or feature requests can be filed on Github .","title":"Reporting problems"},{"location":"#develop","text":"If you want to develop additional functionality or make changes, the usual pull-request approach is the way to go.","title":"Develop"},{"location":"#local-testing","text":"There is a minimal test suite available that uses tox and pytest . To run tests, do a checkout and install dependencies with poetry and then run: tox","title":"Local testing"},{"location":"#documentation","text":"The fantastic MkDocs project is the framework for the documentation written in Markdown. With MkDocs installed, running mkdocs build will build the documentation in the site directory. mkdocs serve will serve up a live preview.","title":"Documentation"},{"location":"#contribution","text":"Contributions are welcome....","title":"Contribution"},{"location":"reference/SUMMARY/","text":"cu_profile_utils pipeline profile_page search_page","title":"SUMMARY"},{"location":"reference/cu_profile_utils/","text":"","title":"Index"},{"location":"reference/cu_profile_utils/pipeline/","text":"","title":"pipeline"},{"location":"reference/cu_profile_utils/profile_page/","text":"ProfilePage Represents a single profile for a member of the CU community The main purpose of this class is to provide a way to get the PMIDs for a given profile. Source code in cu_profile_utils/profile_page.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class ProfilePage : \"\"\"Represents a single profile for a member of the CU community The main purpose of this class is to provide a way to get the PMIDs for a given profile. \"\"\" def __init__ ( self , profile_id : int ): \"\"\"Initialize the ProfilePage object The profile_id is available as a public attribute. \"\"\" self . profile_id = profile_id self . _pmids : list [ str ] = None # type: ignore self . _mesh_terms : list [ dict [ str , Any ]] = None # type: ignore async def _get_profile_page_publications ( self ) -> None : soup = await get_profile_page ( self . profile_id ) pub_div = soup . find ( \"div\" , { \"id\" : \"publicationListAll\" }) self . _pmids = [] if pub_div is None : return lis = pub_div . find_all ( \"li\" ) # type: ignore for pub in lis : pmid = pub . get ( \"data-pmid\" , None ) if pmid is not None : self . _pmids . append ( pmid ) async def get_pmids_as_list ( self ) -> list [ str ]: \"\"\"Return a list of PubMed IDs for the profile\"\"\" if self . _pmids is None : await self . _get_profile_page_publications () return self . _pmids async def get_pmids_as_dataframe ( self , include_profile_id = True ) -> \"pd.DataFrame\" : \"\"\"Return a dataframe of PubMed IDs for the profile\"\"\" pmid_list = await self . get_pmids_as_list () if include_profile_id : return pd . DataFrame ( [{ \"profile_id\" : self . profile_id , \"pmid\" : pmid } for pmid in pmid_list ] ) else : return pd . DataFrame ( pmid_list , columns = [ \"pmid\" ]) async def _get_mesh_term_similarity_table ( self ): soup = await get_mesh_term_similarity_page ( self . profile_id ) table = soup . find ( \"table\" , { \"id\" : \"thetable1\" }) if table is None : self . _mesh_terms = [] return rows = [] for row in table . find_all ( \"tr\" ): # type: ignore cells = row . find_all ( \"td\" ) if len ( cells ) == 0 : continue raw_row_vals = list ([ cell . text for cell in cells ]) rows . append ( fix_mesh_table_raw_row_vals ( raw_row_vals )) self . _mesh_terms = rows async def get_mesh_term_similarities_as_dict ( self , include_profile_id = True ): \"\"\"Return a list of mesh terms and their similarity scores\"\"\" await self . _get_mesh_term_similarity_table () if len ( self . _mesh_terms ) == 0 : return [] if include_profile_id : return [{ \"profile_id\" : self . profile_id , ** row } for row in self . _mesh_terms ] else : return self . _mesh_terms async def get_mesh_term_similarities_as_dataframe ( self , include_profile_id = True ): \"\"\"Return a dataframe of mesh terms and their similarity scores\"\"\" mesh_dict = await self . get_mesh_term_similarities_as_dict () if len ( mesh_dict ) == 0 : return pd . DataFrame () return pd . DataFrame ( mesh_dict ) __init__ ( profile_id ) Initialize the ProfilePage object The profile_id is available as a public attribute. Source code in cu_profile_utils/profile_page.py 49 50 51 52 53 54 55 56 def __init__ ( self , profile_id : int ): \"\"\"Initialize the ProfilePage object The profile_id is available as a public attribute. \"\"\" self . profile_id = profile_id self . _pmids : list [ str ] = None # type: ignore self . _mesh_terms : list [ dict [ str , Any ]] = None # type: ignore get_mesh_term_similarities_as_dataframe ( include_profile_id = True ) async Return a dataframe of mesh terms and their similarity scores Source code in cu_profile_utils/profile_page.py 111 112 113 114 115 116 async def get_mesh_term_similarities_as_dataframe ( self , include_profile_id = True ): \"\"\"Return a dataframe of mesh terms and their similarity scores\"\"\" mesh_dict = await self . get_mesh_term_similarities_as_dict () if len ( mesh_dict ) == 0 : return pd . DataFrame () return pd . DataFrame ( mesh_dict ) get_mesh_term_similarities_as_dict ( include_profile_id = True ) async Return a list of mesh terms and their similarity scores Source code in cu_profile_utils/profile_page.py 101 102 103 104 105 106 107 108 109 async def get_mesh_term_similarities_as_dict ( self , include_profile_id = True ): \"\"\"Return a list of mesh terms and their similarity scores\"\"\" await self . _get_mesh_term_similarity_table () if len ( self . _mesh_terms ) == 0 : return [] if include_profile_id : return [{ \"profile_id\" : self . profile_id , ** row } for row in self . _mesh_terms ] else : return self . _mesh_terms get_pmids_as_dataframe ( include_profile_id = True ) async Return a dataframe of PubMed IDs for the profile Source code in cu_profile_utils/profile_page.py 76 77 78 79 80 81 82 83 84 async def get_pmids_as_dataframe ( self , include_profile_id = True ) -> \"pd.DataFrame\" : \"\"\"Return a dataframe of PubMed IDs for the profile\"\"\" pmid_list = await self . get_pmids_as_list () if include_profile_id : return pd . DataFrame ( [{ \"profile_id\" : self . profile_id , \"pmid\" : pmid } for pmid in pmid_list ] ) else : return pd . DataFrame ( pmid_list , columns = [ \"pmid\" ]) get_pmids_as_list () async Return a list of PubMed IDs for the profile Source code in cu_profile_utils/profile_page.py 70 71 72 73 74 async def get_pmids_as_list ( self ) -> list [ str ]: \"\"\"Return a list of PubMed IDs for the profile\"\"\" if self . _pmids is None : await self . _get_profile_page_publications () return self . _pmids fix_mesh_table_raw_row_vals ( raw_row_vals ) Fix the raw row values from the mesh table Source code in cu_profile_utils/profile_page.py 8 9 10 11 12 13 14 15 16 def fix_mesh_table_raw_row_vals ( raw_row_vals ) -> dict [ str , Any ]: \"\"\"Fix the raw row values from the mesh table\"\"\" return { \"mesh_term\" : raw_row_vals [ 0 ], \"publication_count\" : int ( raw_row_vals [ 1 ]), \"most_recent_publication_year\" : int ( raw_row_vals [ 2 ]), \"publication_count_all_authors\" : int ( raw_row_vals [ 3 ]), \"concept_score\" : float ( raw_row_vals [ 4 ]), } get_pmids_as_dataframe ( self , include_profile_id = True ) Return a dataframe of PubMed IDs for the profile Source code in cu_profile_utils/profile_page.py 35 36 37 38 39 def get_pmids_as_dataframe ( self , include_profile_id = True ) -> \"pd.DataFrame\" : \"\"\"Return a dataframe of PubMed IDs for the profile\"\"\" import pandas as pd return pd . DataFrame ( self . get_pmids_as_list (), columns = [ \"pmid\" ])","title":"profile_page"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.ProfilePage","text":"Represents a single profile for a member of the CU community The main purpose of this class is to provide a way to get the PMIDs for a given profile. Source code in cu_profile_utils/profile_page.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class ProfilePage : \"\"\"Represents a single profile for a member of the CU community The main purpose of this class is to provide a way to get the PMIDs for a given profile. \"\"\" def __init__ ( self , profile_id : int ): \"\"\"Initialize the ProfilePage object The profile_id is available as a public attribute. \"\"\" self . profile_id = profile_id self . _pmids : list [ str ] = None # type: ignore self . _mesh_terms : list [ dict [ str , Any ]] = None # type: ignore async def _get_profile_page_publications ( self ) -> None : soup = await get_profile_page ( self . profile_id ) pub_div = soup . find ( \"div\" , { \"id\" : \"publicationListAll\" }) self . _pmids = [] if pub_div is None : return lis = pub_div . find_all ( \"li\" ) # type: ignore for pub in lis : pmid = pub . get ( \"data-pmid\" , None ) if pmid is not None : self . _pmids . append ( pmid ) async def get_pmids_as_list ( self ) -> list [ str ]: \"\"\"Return a list of PubMed IDs for the profile\"\"\" if self . _pmids is None : await self . _get_profile_page_publications () return self . _pmids async def get_pmids_as_dataframe ( self , include_profile_id = True ) -> \"pd.DataFrame\" : \"\"\"Return a dataframe of PubMed IDs for the profile\"\"\" pmid_list = await self . get_pmids_as_list () if include_profile_id : return pd . DataFrame ( [{ \"profile_id\" : self . profile_id , \"pmid\" : pmid } for pmid in pmid_list ] ) else : return pd . DataFrame ( pmid_list , columns = [ \"pmid\" ]) async def _get_mesh_term_similarity_table ( self ): soup = await get_mesh_term_similarity_page ( self . profile_id ) table = soup . find ( \"table\" , { \"id\" : \"thetable1\" }) if table is None : self . _mesh_terms = [] return rows = [] for row in table . find_all ( \"tr\" ): # type: ignore cells = row . find_all ( \"td\" ) if len ( cells ) == 0 : continue raw_row_vals = list ([ cell . text for cell in cells ]) rows . append ( fix_mesh_table_raw_row_vals ( raw_row_vals )) self . _mesh_terms = rows async def get_mesh_term_similarities_as_dict ( self , include_profile_id = True ): \"\"\"Return a list of mesh terms and their similarity scores\"\"\" await self . _get_mesh_term_similarity_table () if len ( self . _mesh_terms ) == 0 : return [] if include_profile_id : return [{ \"profile_id\" : self . profile_id , ** row } for row in self . _mesh_terms ] else : return self . _mesh_terms async def get_mesh_term_similarities_as_dataframe ( self , include_profile_id = True ): \"\"\"Return a dataframe of mesh terms and their similarity scores\"\"\" mesh_dict = await self . get_mesh_term_similarities_as_dict () if len ( mesh_dict ) == 0 : return pd . DataFrame () return pd . DataFrame ( mesh_dict )","title":"ProfilePage"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.ProfilePage.__init__","text":"Initialize the ProfilePage object The profile_id is available as a public attribute. Source code in cu_profile_utils/profile_page.py 49 50 51 52 53 54 55 56 def __init__ ( self , profile_id : int ): \"\"\"Initialize the ProfilePage object The profile_id is available as a public attribute. \"\"\" self . profile_id = profile_id self . _pmids : list [ str ] = None # type: ignore self . _mesh_terms : list [ dict [ str , Any ]] = None # type: ignore","title":"__init__()"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.ProfilePage.get_mesh_term_similarities_as_dataframe","text":"Return a dataframe of mesh terms and their similarity scores Source code in cu_profile_utils/profile_page.py 111 112 113 114 115 116 async def get_mesh_term_similarities_as_dataframe ( self , include_profile_id = True ): \"\"\"Return a dataframe of mesh terms and their similarity scores\"\"\" mesh_dict = await self . get_mesh_term_similarities_as_dict () if len ( mesh_dict ) == 0 : return pd . DataFrame () return pd . DataFrame ( mesh_dict )","title":"get_mesh_term_similarities_as_dataframe()"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.ProfilePage.get_mesh_term_similarities_as_dict","text":"Return a list of mesh terms and their similarity scores Source code in cu_profile_utils/profile_page.py 101 102 103 104 105 106 107 108 109 async def get_mesh_term_similarities_as_dict ( self , include_profile_id = True ): \"\"\"Return a list of mesh terms and their similarity scores\"\"\" await self . _get_mesh_term_similarity_table () if len ( self . _mesh_terms ) == 0 : return [] if include_profile_id : return [{ \"profile_id\" : self . profile_id , ** row } for row in self . _mesh_terms ] else : return self . _mesh_terms","title":"get_mesh_term_similarities_as_dict()"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.ProfilePage.get_pmids_as_dataframe","text":"Return a dataframe of PubMed IDs for the profile Source code in cu_profile_utils/profile_page.py 76 77 78 79 80 81 82 83 84 async def get_pmids_as_dataframe ( self , include_profile_id = True ) -> \"pd.DataFrame\" : \"\"\"Return a dataframe of PubMed IDs for the profile\"\"\" pmid_list = await self . get_pmids_as_list () if include_profile_id : return pd . DataFrame ( [{ \"profile_id\" : self . profile_id , \"pmid\" : pmid } for pmid in pmid_list ] ) else : return pd . DataFrame ( pmid_list , columns = [ \"pmid\" ])","title":"get_pmids_as_dataframe()"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.ProfilePage.get_pmids_as_list","text":"Return a list of PubMed IDs for the profile Source code in cu_profile_utils/profile_page.py 70 71 72 73 74 async def get_pmids_as_list ( self ) -> list [ str ]: \"\"\"Return a list of PubMed IDs for the profile\"\"\" if self . _pmids is None : await self . _get_profile_page_publications () return self . _pmids","title":"get_pmids_as_list()"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.fix_mesh_table_raw_row_vals","text":"Fix the raw row values from the mesh table Source code in cu_profile_utils/profile_page.py 8 9 10 11 12 13 14 15 16 def fix_mesh_table_raw_row_vals ( raw_row_vals ) -> dict [ str , Any ]: \"\"\"Fix the raw row values from the mesh table\"\"\" return { \"mesh_term\" : raw_row_vals [ 0 ], \"publication_count\" : int ( raw_row_vals [ 1 ]), \"most_recent_publication_year\" : int ( raw_row_vals [ 2 ]), \"publication_count_all_authors\" : int ( raw_row_vals [ 3 ]), \"concept_score\" : float ( raw_row_vals [ 4 ]), }","title":"fix_mesh_table_raw_row_vals()"},{"location":"reference/cu_profile_utils/profile_page/#cu_profile_utils.profile_page.get_pmids_as_dataframe","text":"Return a dataframe of PubMed IDs for the profile Source code in cu_profile_utils/profile_page.py 35 36 37 38 39 def get_pmids_as_dataframe ( self , include_profile_id = True ) -> \"pd.DataFrame\" : \"\"\"Return a dataframe of PubMed IDs for the profile\"\"\" import pandas as pd return pd . DataFrame ( self . get_pmids_as_list (), columns = [ \"pmid\" ])","title":"get_pmids_as_dataframe()"},{"location":"reference/cu_profile_utils/search_page/","text":"SearchPage Represents a single Profile Search Page Usually, one will want to loop over these pages to get all the data. Source code in cu_profile_utils/search_page.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class SearchPage : \"\"\"Represents a single Profile Search Page Usually, one will want to loop over these pages to get all the data. \"\"\" def __init__ ( self , page_size : int = 100 , page = 1 ): \"\"\"Create a new ProfileSearch page is (one-based) and default page_size of 100 is the maximum allowed by the site. \"\"\" self . page_size = page_size self . page = page self . _get_search_page_soup () self . _get_profile_table_data () def get_results ( self ) -> pd . DataFrame : \"\"\"Return the data as a list of `ProfileTableRow` objects\"\"\" return self . _data # perform http request to get the page and # parse to a BeautifulSoup object def _get_search_page_soup ( self ): page = self . page page_size = self . page_size url = f \"https://profiles.ucdenver.edu/search/default.aspx?searchtype=people&searchfor=&exactphrase=false&perpage= { page_size } &offset=0&page= { page } &totalpages=569&searchrequest=A81BSfTwU3GNm4liSODkW6vB3EBYO6gz+a5TY1bFhuz1tc7ngL4Orww3064KoquGaRdozjhWRGlrnur5IbaEcMH3TeE05jmp/c7agcYTrzG/rrN5T5p39rbdUtWdCA0xO6jz/+zNo8xTen6DVgqqi0W/y1wHaBbEaTD7d+ObAfEiPSt4sYkjfpHHCVWp3IgQjZuJYkjg5FtrbjF9BEDCXidTb5mQuzDHyB9Btw8xWu0u+sg0NH5oV8eO5TZfqG6zAJei5w7JqjuiyOFytEGpzItfRAJL6BXOyZmTRCU0RtrqmPKU0fOLSVV35kew5OQiQnv3EOh+q7Y=&sortby=&sortdirection=&showcolumns=11\" response = httpx . get ( url , timeout = 20 ) soup = BeautifulSoup ( response . text , \"html.parser\" ) self . _soup = soup # Gets the rows of the table that contains the search results # and returns a list of ProfileTableRow objects def _get_tbl_srch_result_rows ( self ): table = self . _soup . find ( \"table\" , { \"id\" : \"tblSearchResults\" }) rows = table . find_all ( \"tr\" ) # type: ignore return rows # parse the rows into a list of ProfileTableRow objects def _get_profile_table_data ( self ): rows = self . _get_tbl_srch_result_rows () data = [] for row in rows : cols = row . find_all ( \"td\" ) if len ( cols ) == 0 : continue table_row = create_profile_table_row_from_tds ( cols ) data . append ( table_row ) self . _data = pd . DataFrame ([ asdict ( record ) for record in data ]) def has_next_page ( self ): return self . _soup . find ( \"a\" , { \"href\" : \"javascript:GotoNextPage();\" }) is not None __init__ ( page_size = 100 , page = 1 ) Create a new ProfileSearch page is (one-based) and default page_size of 100 is the maximum allowed by the site. Source code in cu_profile_utils/search_page.py 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , page_size : int = 100 , page = 1 ): \"\"\"Create a new ProfileSearch page is (one-based) and default page_size of 100 is the maximum allowed by the site. \"\"\" self . page_size = page_size self . page = page self . _get_search_page_soup () self . _get_profile_table_data () get_results () Return the data as a list of ProfileTableRow objects Source code in cu_profile_utils/search_page.py 52 53 54 def get_results ( self ) -> pd . DataFrame : \"\"\"Return the data as a list of `ProfileTableRow` objects\"\"\" return self . _data SearchTableRow dataclass A row of data from a profile page table Source code in cu_profile_utils/search_page.py 12 13 14 15 16 17 18 19 20 @dataclass class SearchTableRow : \"\"\"A row of data from a profile page table\"\"\" name : str institution : str department : str title : str profile_id : int create_profile_table_row_from_tds ( columns ) Create a ProfileTableRow from a list of td elements Source code in cu_profile_utils/search_page.py 23 24 25 26 27 28 29 30 31 def create_profile_table_row_from_tds ( columns : list [ Tag ]) -> SearchTableRow : \"\"\"Create a ProfileTableRow from a list of td elements\"\"\" return SearchTableRow ( name = get_td_text ( columns [ 0 ]), institution = get_td_text ( columns [ 1 ]), department = get_td_text ( columns [ 2 ]), title = get_td_text ( columns [ 3 ]), profile_id = int ( columns [ 0 ] . find ( \"a\" )[ \"href\" ] . split ( \"/\" )[ - 1 ]), # type: ignore ) get_td_text ( td_element ) Utility function to get the text from a td element Source code in cu_profile_utils/search_page.py 7 8 9 def get_td_text ( td_element : Tag ) -> str : \"\"\"Utility function to get the text from a td element\"\"\" return td_element . text . strip ()","title":"search_page"},{"location":"reference/cu_profile_utils/search_page/#cu_profile_utils.search_page.SearchPage","text":"Represents a single Profile Search Page Usually, one will want to loop over these pages to get all the data. Source code in cu_profile_utils/search_page.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class SearchPage : \"\"\"Represents a single Profile Search Page Usually, one will want to loop over these pages to get all the data. \"\"\" def __init__ ( self , page_size : int = 100 , page = 1 ): \"\"\"Create a new ProfileSearch page is (one-based) and default page_size of 100 is the maximum allowed by the site. \"\"\" self . page_size = page_size self . page = page self . _get_search_page_soup () self . _get_profile_table_data () def get_results ( self ) -> pd . DataFrame : \"\"\"Return the data as a list of `ProfileTableRow` objects\"\"\" return self . _data # perform http request to get the page and # parse to a BeautifulSoup object def _get_search_page_soup ( self ): page = self . page page_size = self . page_size url = f \"https://profiles.ucdenver.edu/search/default.aspx?searchtype=people&searchfor=&exactphrase=false&perpage= { page_size } &offset=0&page= { page } &totalpages=569&searchrequest=A81BSfTwU3GNm4liSODkW6vB3EBYO6gz+a5TY1bFhuz1tc7ngL4Orww3064KoquGaRdozjhWRGlrnur5IbaEcMH3TeE05jmp/c7agcYTrzG/rrN5T5p39rbdUtWdCA0xO6jz/+zNo8xTen6DVgqqi0W/y1wHaBbEaTD7d+ObAfEiPSt4sYkjfpHHCVWp3IgQjZuJYkjg5FtrbjF9BEDCXidTb5mQuzDHyB9Btw8xWu0u+sg0NH5oV8eO5TZfqG6zAJei5w7JqjuiyOFytEGpzItfRAJL6BXOyZmTRCU0RtrqmPKU0fOLSVV35kew5OQiQnv3EOh+q7Y=&sortby=&sortdirection=&showcolumns=11\" response = httpx . get ( url , timeout = 20 ) soup = BeautifulSoup ( response . text , \"html.parser\" ) self . _soup = soup # Gets the rows of the table that contains the search results # and returns a list of ProfileTableRow objects def _get_tbl_srch_result_rows ( self ): table = self . _soup . find ( \"table\" , { \"id\" : \"tblSearchResults\" }) rows = table . find_all ( \"tr\" ) # type: ignore return rows # parse the rows into a list of ProfileTableRow objects def _get_profile_table_data ( self ): rows = self . _get_tbl_srch_result_rows () data = [] for row in rows : cols = row . find_all ( \"td\" ) if len ( cols ) == 0 : continue table_row = create_profile_table_row_from_tds ( cols ) data . append ( table_row ) self . _data = pd . DataFrame ([ asdict ( record ) for record in data ]) def has_next_page ( self ): return self . _soup . find ( \"a\" , { \"href\" : \"javascript:GotoNextPage();\" }) is not None","title":"SearchPage"},{"location":"reference/cu_profile_utils/search_page/#cu_profile_utils.search_page.SearchPage.__init__","text":"Create a new ProfileSearch page is (one-based) and default page_size of 100 is the maximum allowed by the site. Source code in cu_profile_utils/search_page.py 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , page_size : int = 100 , page = 1 ): \"\"\"Create a new ProfileSearch page is (one-based) and default page_size of 100 is the maximum allowed by the site. \"\"\" self . page_size = page_size self . page = page self . _get_search_page_soup () self . _get_profile_table_data ()","title":"__init__()"},{"location":"reference/cu_profile_utils/search_page/#cu_profile_utils.search_page.SearchPage.get_results","text":"Return the data as a list of ProfileTableRow objects Source code in cu_profile_utils/search_page.py 52 53 54 def get_results ( self ) -> pd . DataFrame : \"\"\"Return the data as a list of `ProfileTableRow` objects\"\"\" return self . _data","title":"get_results()"},{"location":"reference/cu_profile_utils/search_page/#cu_profile_utils.search_page.SearchTableRow","text":"A row of data from a profile page table Source code in cu_profile_utils/search_page.py 12 13 14 15 16 17 18 19 20 @dataclass class SearchTableRow : \"\"\"A row of data from a profile page table\"\"\" name : str institution : str department : str title : str profile_id : int","title":"SearchTableRow"},{"location":"reference/cu_profile_utils/search_page/#cu_profile_utils.search_page.create_profile_table_row_from_tds","text":"Create a ProfileTableRow from a list of td elements Source code in cu_profile_utils/search_page.py 23 24 25 26 27 28 29 30 31 def create_profile_table_row_from_tds ( columns : list [ Tag ]) -> SearchTableRow : \"\"\"Create a ProfileTableRow from a list of td elements\"\"\" return SearchTableRow ( name = get_td_text ( columns [ 0 ]), institution = get_td_text ( columns [ 1 ]), department = get_td_text ( columns [ 2 ]), title = get_td_text ( columns [ 3 ]), profile_id = int ( columns [ 0 ] . find ( \"a\" )[ \"href\" ] . split ( \"/\" )[ - 1 ]), # type: ignore )","title":"create_profile_table_row_from_tds()"},{"location":"reference/cu_profile_utils/search_page/#cu_profile_utils.search_page.get_td_text","text":"Utility function to get the text from a td element Source code in cu_profile_utils/search_page.py 7 8 9 def get_td_text ( td_element : Tag ) -> str : \"\"\"Utility function to get the text from a td element\"\"\" return td_element . text . strip ()","title":"get_td_text()"}]}